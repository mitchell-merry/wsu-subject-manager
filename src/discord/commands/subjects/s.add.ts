import { AutocompleteInteraction, Channel, CommandInteraction, GuildBasedChannel, GuildChannel, Role, OverwriteResolvable } from "discord.js";
import { DB, GuildEntity, SubjectEntity, SubjectInGuildEntity } from "../../../db";
import UserError from "../../UserError";
import { canHandleRole } from "../../util";

const reason = 'Auto-generated by WSU bot. Mitch is responsible';

export async function add(interaction: CommandInteraction) {
	await interaction.deferReply();

	const sgRepo = DB.getRepository(SubjectInGuildEntity)
	const gRepo = DB.getRepository(GuildEntity);
	const sRepo = DB.getRepository(SubjectEntity);

	const guildEnt = await gRepo.findOne({ where: { guild_id: interaction.guildId! }});
	if(!guildEnt) throw new Error("error, guild no set lol.");

	const subject = interaction.options.getString('subject');
	const subjEnt = await sRepo.findOne({ where: { subject_code: subject! } });
	if(!subjEnt) throw new UserError('Invalid subject code! Only use the given autocomplete function to enter a code!');

	const sgEnt = await sgRepo.findOne({ where: { subject_code: subject!, guild_id: interaction.guildId! }});
	if(sgEnt) throw new UserError(`The subject ${subjEnt.name} is already tracked in this server.`);

	let role = interaction.options.getRole('role') as Role;
	let gbChannel = interaction.options.getChannel('channel') as GuildBasedChannel;
	if(gbChannel.type !== 'GUILD_TEXT' && gbChannel.type !== 'GUILD_CATEGORY') throw new UserError(`Channel must be a category or text channel.`);
	if(gbChannel.type === 'GUILD_CATEGORY' && gbChannel.children.size >= 50) throw new UserError(`Category is full! Categories can only have max 50 channels, and ${gbChannel.name} has ${gbChannel.children.size}.`);

	let parent_role: Role | null;
	if(!role) {
		if(!guildEnt.parent_role) throw new UserError("Parent role is required atm.");
	
		parent_role = await interaction.guild!.roles.fetch(guildEnt.parent_role);
		if(!parent_role) throw new UserError('Parent role doesn\'t exist.');
	}

	// If the bot can't mess with the given role
	if(role && !canHandleRole(role, interaction.guild!.me!)) throw new UserError("Given role is higher than the bot's highest role. Either move the bot's role higher, or move the given role down so it can be managed. LET ME MANAGE IT!!!");
	
	if(!role) {
		// make rol
		role = await interaction.guild!.roles.create({ 
			mentionable: false,
			reason,
			permissions: [ ], // no special permissions given by roles
			position: parent_role!.position,
			name: subjEnt.name
		});
	}
	
	let channel: GuildChannel | undefined;
	if(gbChannel) {
		const permissionOverwrites: OverwriteResolvable[] = [
			{ id: interaction.guild!.me!.id, allow: 'VIEW_CHANNEL' },
			{ id: role.id, allow: 'VIEW_CHANNEL' },
			{ id: interaction.guild!.roles.everyone.id, deny: 'VIEW_CHANNEL' },
		];

		if(gbChannel.type === 'GUILD_CATEGORY') {
			channel = await gbChannel.createChannel(subjEnt.name, { 
				type: 'GUILD_TEXT',
				reason,
				topic: `${subjEnt.subject_code} - ${subjEnt.details_link}`,
				permissionOverwrites,
				nsfw: false
			});
		} else {
			channel = gbChannel;

			// update perms to be corncrect
			await channel.permissionOverwrites.set(permissionOverwrites, reason);
		}
	} 
	
	// create relation in DB
	await sgRepo.save(sgRepo.create({ guild: guildEnt, subject: subjEnt, role: role.id, channel: channel?.id }));

	await interaction.editReply('subcfeful.');
}

export async function autocomplete(interaction: AutocompleteInteraction) {
	const subjRepo = DB.getRepository(SubjectEntity);
	const val = interaction.options.getFocused(true).value.toLowerCase();

	let subjFiltered = (await subjRepo.find()).filter(subj => {
		const n = `${subj.subject_code} ${subj.name}`.toLowerCase();
		return n.includes(val);
	});

	subjFiltered.sort((subjA, subjB) => {
		const aname = `${subjA.subject_code} ${subjA.name}`.toLowerCase();
		const bname = `${subjB.subject_code} ${subjB.name}`.toLowerCase();
		return aname.indexOf(val) - bname.indexOf(val);
	});
	
	const options = subjFiltered.map(subj => ({
		name: `${subj.subject_code} ${subj.name}`,
		value: subj.subject_code
	})).slice(0, 25);

	interaction.respond(options);
}